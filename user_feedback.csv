"2025-06-16 17:53:18","Naive Bayes","NEW DELHI ‚Äî An Air India Boeing 787-8 Dreamliner plane bound for New Delhi returned to its origin of Hong Kong shortly after takeoff on Monday as a precautionary measure following a suspected technical issue.\n\nLast week, an Air India flight to London, using the same type of Boeing aircraft, crashed in the western Indian city of Ahmedabad moments after takeoff, killing 241 of the 242 people on board.\n\nAir India said in a statement on Monday that flight AI315 returned to Hong Kong because of what it described as ‚Äúa technical issue‚Äù without giving details.\n\nIt said the flight landed safely and was undergoing checks ‚Äúas a matter of abundant precaution.‚Äù\n\nAccording to recordings posted on air traffic control monitoring website LiveATC.net, and reviewed by Reuters, one of the pilots in the plane told air traffic controllers around 15 minutes after takeoff that ‚Äúfor technical reasons, sir, we would like to stay closer to Hong Kong, maybe we will come back and land back into Hong Kong once we sort out the problem.‚Äù\n\n‚ÄúWe don‚Äôt want to continue further,‚Äù the pilot said, before returning.\n\nAir India did not respond to a Reuters request for comment on the recording.","business","Correct",""
"2025-06-16 17:54:08","SVM","NEW DELHI ‚Äî An Air India Boeing 787-8 Dreamliner plane bound for New Delhi returned to its origin of Hong Kong shortly after takeoff on Monday as a precautionary measure following a suspected technical issue.\n\nLast week, an Air India flight to London, using the same type of Boeing aircraft, crashed in the western Indian city of Ahmedabad moments after takeoff, killing 241 of the 242 people on board.\n\nAir India said in a statement on Monday that flight AI315 returned to Hong Kong because of what it described as ‚Äúa technical issue‚Äù without giving details.\n\nIt said the flight landed safely and was undergoing checks ‚Äúas a matter of abundant precaution.‚Äù\n\nAccording to recordings posted on air traffic control monitoring website LiveATC.net, and reviewed by Reuters, one of the pilots in the plane told air traffic controllers around 15 minutes after takeoff that ‚Äúfor technical reasons, sir, we would like to stay closer to Hong Kong, maybe we will come back and land back into Hong Kong once we sort out the problem.‚Äù\n\n‚ÄúWe don‚Äôt want to continue further,‚Äù the pilot said, before returning.\n\nAir India did not respond to a Reuters request for comment on the recording.","business","Incorrect","politics"
"2025-06-16 18:18:44","SVM","import streamlit as st\nimport pandas as pd\nimport re\nimport pickle\nimport json\nimport plotly.graph_objects as go\nimport numpy as np\nfrom scipy.sparse import issparse\nfrom datetime import datetime\nimport os\nimport time # New import for measuring prediction time\n\n# --- Page Configuration ---\nst.set_page_config(\n    page_title=""NewsTagger AI"",\n    page_icon=""üì∞üè∑Ô∏è"",\n    layout=""centered"",\n    initial_sidebar_state=""expanded""\n)\n\n# --- GLOBAL CONFIGURATIONS ---\n\n# Define a color map for categories for consistent visualization\nCATEGORY_COLORS = {\n    'Business': '#FFD700',   # Gold\n    'Politics': '#DC143C',   # Crimson\n    'Sports': '#00BFFF',     # Deep Sky Blue\n    'Tech': '#32CD32',       # Lime Green\n    'Entertainment': '#9370DB', # Medium Purple\n    # Add more categories and colors if needed\n}\n\n# Define category descriptions for ""Meet the Categories"" section\nCATEGORY_DESCRIPTIONS = {\n    'Business': ""Articles covering economy, finance, markets, companies, and corporate news."",\n    'Politics': ""News related to government, elections, policies, international relations, and political figures."",\n    'Sports': ""Content focused on athletic events, teams, athletes, and various sports news like football, basketball, etc."",\n    'Tech': ""Reports on technology, gadgets, software, artificial intelligence, and scientific breakthroughs."",\n    'Entertainment': ""Stories about film, music, art, celebrity news, pop culture, and leisure activities.""\n}\n\n\n# --- ADVANCED CSS FOR MATERIAL DARK UI & ANIMATIONS ---\nst.markdown(""""""\n    <style>\n    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap');\n    @import url('https://fonts.googleapis.com/icon?family=Material+Icons');\n\n    /* Keyframes for animations */\n    @keyframes fadeIn {\n        from { opacity: 0; transform: translateY(20px); }\n        to { opacity: 1; transform: translateY(0); }\n    }\n    @keyframes ripple {\n      to {\n        transform: scale(4);\n        opacity: 0;\n      }\n    }\n\n    /* Base styles */\n    html, body, [class*=""st-""] {\n        font-family: 'Roboto', sans-serif;\n        color: #e0e0e0;\n    }\n    .main {\n        background-color: #121212; /* Material Dark Background */\n    }\n    h1, h2, h3 { color: #ffffff; }\n\n    /* Sidebar */\n    .css-1d391kg { /* Target for Streamlit sidebar */\n        background-color: #1E1E1E; /* Surface Color */\n        border-right: 1px solid #303030;\n    }\n\n    /* Text Area */\n    .stTextArea textarea {\n        background-color: #212121;\n        border: 1px solid #424242;\n        border-radius: 8px;\n        color: #e0e0e0;\n        font-size: 16px;\n        box-shadow: 0 1px 2px rgba(0,0,0,0.3);\n    }\n    .stTextArea textarea:focus {\n        border-color: #64B5F6;\n        box-shadow: 0 0 5px rgba(100, 181, 246, 0.5);\n    }\n    \n    /* Global Button Styles (Predict/Clear) */\n    .stButton > button {\n        position: relative;\n        overflow: hidden;\n        background-color: #64B5F6;\n        color: #121212;\n        border: none;\n        padding: 12px 28px;\n        border-radius: 8px;\n        font-size: 14px;\n        font-weight: 700;\n        text-transform: uppercase;\n        box-shadow: 0 4px 6px rgba(0,0,0,0.3);\n        transition: box-shadow 0.3s ease, transform 0.1s ease, background-color 0.3s ease;\n    }\n    .stButton > button:hover {\n        box-shadow: 0 6px 12px rgba(0,0,0,0.4);\n        background-color: #42A5F5; /* Slightly darker blue on hover */\n    }\n    .stButton > button:active {\n        transform: translateY(1px);\n        box-shadow: 0 2px 4px rgba(0,0,0,0.3);\n    }\n    \n    /* Action Buttons (General Styling for st.button containers like Predict/Clear) */\n    div.stButton {\n        width: 100%;\n        margin-top: 10px;\n        transition: all 0.3s ease;\n    }\n    div.stButton > button {\n        width: 100%;\n    }\n    div.stButton:hover {\n        transform: translateY(-2px);\n        box-shadow: 0 6px 12px rgba(100, 181, 246, 0.4);\n    }\n\n\n    /* CUSTOM MODEL SELECTION CARDS */\n\n    /* The outer wrapper for positioning */\n    .model-card-container {\n        position: relative; /* Crucial for positioning the button inside */\n        height: 180px; /* Fixed height for consistent layout */\n        margin-bottom: 15px; /* Spacing between cards */\n        cursor: pointer; /* Indicate clickability for the whole card */\n        border-radius: 8px;\n        transition: all 0.2s ease-in-out;\n    }\n    \n    /* Styles for the custom card's visual appearance */\n    .model-card-visual {\n        background-color: #212121;\n        padding: 1rem;\n        border-radius: 8px;\n        border: 2px solid #424242;\n        text-align: center;\n        box-shadow: 0 2px 4px rgba(0,0,0,0.3);\n        height: 100%;\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n        position: absolute; /* Position over the button */\n        top: 0;\n        left: 0;\n        width: 100%;\n        z-index: 2; /* Make sure it's above the button */\n        pointer-events: none; /* Allow clicks to pass through to the button */\n        transition: inherit; /* Inherit transitions from container */\n    }\n\n    /* Selected state for the custom card's visual */\n    .model-card-container.selected .model-card-visual {\n        border-color: #64B5F6;\n        background: rgba(100, 181, 246, 0.1);\n        box-shadow: 0 0 10px rgba(100, 181, 246, 0.5);\n    }\n    \n    /* Hover effect for the entire card container */\n    .model-card-container:hover {\n        transform: translateY(-3px);\n        box-shadow: 0 4px 8px rgba(0,0,0,0.4);\n    }\n    .model-card-container:hover .model-card-visual {\n         border-color: #64B5F6; /* Also update the border on hover */\n    }\n\n    /* Checkmark icon for selected cards */\n    .model-card-container.selected .model-card-visual::after {\n        content: 'check_circle'; /* Material icon name */\n        font-family: 'Material Icons';\n        font-size: 2rem;\n        color: #4CAF50; /* Green checkmark */\n        position: absolute;\n        top: 10px;\n        right: 10px;\n        line-height: 1;\n    }\n\n    /* Hide default Streamlit button styling */\n    .model-selection-button > button {\n        position: absolute !important;\n        top: 0 !important;\n        left: 0 !important;\n        width: 100% !important;\n        height: 100% !important;\n        background-color: transparent !important;\n        border: none !important;\n        box-shadow: none !important;\n        color: transparent !important; /* Hide text */\n        z-index: 1 !important; /* Place it below the visual but above parent */\n        cursor: pointer !important;\n        padding: 0 !important;\n        margin: 0 !important;\n        /* Prevent Streamlit's default hover effects on the hidden button */\n        transition: none !important; \n    }\n    /* Hide the focus outline from the actual button but let it be on the custom card */\n    .model-selection-button > button:focus {\n        outline: none !important;\n        box-shadow: none !important;\n    }\n    /* Hide the div.stButton's default margin for model selection buttons */\n    .model-selection-button {\n        margin: 0 !important;\n        height: 100% !important; /* Important for the parent div.stButton to fill model-card-container */\n    }\n\n    /* Prediction Result Cards */\n    .prediction-card {\n        background: #1E1E1E;\n        padding: 24px;\n        border-radius: 8px;\n        box-shadow: 0 4px 8px rgba(0,0,0,0.4);\n        margin-top: 15px;\n        animation: fadeIn 0.5s ease-out forwards;\n        border-left: 5px solid var(--category-color, #64B5F6); /* Dynamic border color */\n    }\n    .prediction-header {\n        font-size: 20px;\n        font-weight: 700;\n        color: #ffffff;\n    }\n    .prediction-category {\n        font-size: 24px;\n        font-weight: 500;\n        color: var(--category-color, #64B5F6); /* Dynamic text color */\n        text-align: center;\n        margin: 15px 0;\n    }\n    \n    /* Tabs */\n    .stTabs [role=""tablist""] {\n        background-color: #1E1E1E;\n        border-radius: 8px;\n        padding: 4px;\n        margin-bottom: 1rem;\n    }\n    .stTabs [role=""tab""] {\n        color: #9e9e9e;\n        background-color: transparent;\n        border-radius: 6px;\n        padding: 8px 16px;\n        margin: 0 2px;\n        transition: all 0.3s;\n    }\n    .stTabs [role=""tab""][aria-selected=""true""] {\n        color: #64B5F6;\n        background-color: rgba(100, 181, 246, 0.1);\n        font-weight: 500;\n    }\n    .stTabs [role=""tab""]:hover:not([aria-selected=""true""]) {\n        background-color: rgba(100, 181, 246, 0.05);\n    }\n    \n    /* Metrics */\n    .metric-card {\n        background-color: #212121;\n        padding: 16px;\n        border-radius: 8px;\n        text-align: center;\n        box-shadow: 0 2px 4px rgba(0,0,0,0.3);\n        height: 100%; /* Ensure equal height for metric cards */\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n    }\n    .metric-value {\n        font-size: 24px;\n        font-weight: 700;\n        color: #64B5F6;\n        margin: 8px 0;\n    }\n    .metric-label {\n        font-size: 14px;\n        color: #9e9e9e;\n    }\n    </style>\n"""""", unsafe_allow_html=True)\n\n# --- HELPER & UI FUNCTIONS ---\n@st.cache_data\ndef preprocess_text(text):\n    text = str(text).lower()\n    text = re.sub(r'[^a-zA-Z\s]', '', text)\n    text = ' '.join(text.split())\n    return text\n\n@st.cache_resource\ndef load_resources():\n    try:\n        # These paths assume the pickle and JSON files are in the same directory as your app.py\n        with open('vectorizer.pkl', 'rb') as f: vectorizer = pickle.load(f)\n        with open('label_encoder.pkl', 'rb') as f: label_encoder = pickle.load(f)\n        with open('model_accuracies.json', 'r') as f: accuracies = json.load(f)\n        return vectorizer, label_encoder, accuracies\n    except FileNotFoundError:\n        st.error(""üö® Required model files not found. Please run the training script first."", icon=""üî•"")\n        st.stop()\n\n@st.cache_resource\ndef load_model(model_name):\n    model_file = f'model_{model_name.lower().replace("" "", ""_"")}.pkl'\n    try:\n        with open(model_file, 'rb') as f: model = pickle.load(f)\n        return model\n    except FileNotFoundError: \n        st.error(f""üö® Model file not found: {model_file}"", icon=""‚ùå"")\n        return None\n\ndef create_confidence_chart(probabilities, labels, category_colors):\n    prob_df = pd.DataFrame({'Category': labels, 'Probability': probabilities})\n    prob_df = prob_df.sort_values(by='Probability', ascending=True)\n\n    # Create a list of colors for the bars based on their category\n    bar_colors = [category_colors.get(cat, '#64B5F6') for cat in prob_df['Category']] # Default blue if category not found\n\n    fig = go.Figure(go.Bar(\n        x=prob_df['Probability'], y=prob_df['Category'], orientation='h',\n        marker_color=bar_colors, # Use the list of colors here\n        text=prob_df['Probability'].apply(lambda x: f'{x:.1%}'),\n        textposition='outside'\n    ))\n    fig.update_layout(\n        title_text='Confidence Scores', title_x=0.5,\n        xaxis_title=""Probability"", yaxis_title=None,\n        plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)',\n        font_color='#e0e0e0', xaxis=dict(gridcolor='#424242', range=[0, 1]),\n        yaxis=dict(showgrid=False), bargap=0.2, height=450\n    )\n    return fig\n\ndef create_feature_importance_chart(importances, feature_names, top_n=15):\n    # Ensure importances is 1D and feature_names match\n    importances = np.asarray(importances)\n    if importances.ndim > 1:\n        importances = importances.flatten()\n    \n    # Handle cases where feature_names might not exactly match importances length\n    if len(importances) != len(feature_names):\n        # st.warning(f""Feature importance length ({len(importances)}) does not match feature names length ({len(feature_names)}). This might affect the chart."", icon=""‚ö†Ô∏è"")\n        if len(importances) > len(feature_names):\n            importances = importances[:len(feature_names)]\n        elif len(feature_names) > len(importances):\n            importances = np.pad(importances, (0, len(feature_names) - len(importances)), 'constant')\n        \n        if len(importances) == 0: # If after adjustments, there are no features\n             return None\n\n    # Create DataFrame for feature importances\n    importance_df = pd.DataFrame({\n        'Feature': feature_names,\n        'Importance': np.abs(importances) # Use absolute importance for ranking\n    }).sort_values('Importance', ascending=False).head(top_n)\n    \n    if importance_df.empty:\n        return None\n\n    # Create horizontal bar chart\n    fig = go.Figure(go.Bar(\n        x=importance_df['Importance'],\n        y=importance_df['Feature'],\n        orientation='h',\n        marker_color='#64B5F6'\n    ))\n    fig.update_layout(\n        title='Top Influential Words',\n        height=500, # Increased height\n        xaxis_title=""Importance Score (Absolute)"",\n        yaxis_title=None,\n        plot_bgcolor='rgba(0,0,0,0)',\n        paper_bgcolor='rgba(0,0,0,0)',\n        font_color='#e0e0e0',\n        yaxis=dict(autorange=""reversed"")\n    )\n    return fig\n\ndef log_feedback(timestamp, model_name, user_input, predicted_category, feedback_type, correct_category=None, reason=None):\n    """"""Logs user feedback to a CSV file.""""""\n    feedback_file = 'user_feedback.csv'\n    file_exists = os.path.exists(feedback_file)\n    \n    with open(feedback_file, 'a', encoding='utf-8') as f: # Added encoding for broader compatibility\n        if not file_exists:\n            f.write(""timestamp,model_name,user_input,predicted_category,feedback_type,correct_category,reason\n"")\n        # Escape double quotes and newlines for CSV format\n        sanitized_user_input = user_input.replace('""', '""""').replace('\n', '\\n').replace('\r', '\\r')\n        sanitized_reason = reason.replace('""', '""""').replace('\n', '\\n').replace('\r', '\\r') if reason else """"\n        f.write(f'""{timestamp}"",""{model_name}"",""{sanitized_user_input}"",'\n                f'""{predicted_category}"",""{feedback_type}"",""{correct_category if correct_category else """"}"",""{sanitized_reason}""\n')\n    st.toast(""Feedback submitted! Thank you."", icon=""‚úÖ"")\n\n# --- LOAD RESOURCES & INITIALIZE STATE ---\nvectorizer, label_encoder, accuracies = load_resources()\n\n# Simulate class-wise metrics data for demonstration\n# In a real application, this would come from your model evaluation pipeline.\n# Key format: {model_name: {category: {precision: val, recall: val, f1: val}}}\nsimulated_class_metrics = {\n    'Naive Bayes': {\n        'Business': {'precision': 0.88, 'recall': 0.90, 'f1': 0.89},\n        'Politics': {'precision': 0.85, 'recall': 0.82, 'f1': 0.83},\n        'Sports': {'precision': 0.92, 'recall': 0.91, 'f1': 0.91},\n        'Tech': {'precision': 0.87, 'recall': 0.89, 'f1': 0.88},\n        'Entertainment': {'precision': 0.80, 'recall': 0.78, 'f1': 0.79}\n    },\n    'SVM': {\n        'Business': {'precision': 0.91, 'recall': 0.92, 'f1': 0.91},\n        'Politics': {'precision': 0.89, 'recall': 0.88, 'f1': 0.88},\n        'Sports': {'precision': 0.94, 'recall': 0.93, 'f1': 0.93},\n        'Tech': {'precision': 0.90, 'recall': 0.91, 'f1': 0.90},\n        'Entertainment': {'precision': 0.85, 'recall': 0.83, 'f1': 0.84}\n    },\n    'Random Forest': {\n        'Business': {'precision': 0.89, 'recall': 0.88, 'f1': 0.88},\n        'Politics': {'precision': 0.87, 'recall': 0.86, 'f1': 0.86},\n        'Sports': {'precision': 0.93, 'recall': 0.92, 'f1': 0.92},\n        'Tech': {'precision': 0.89, 'recall': 0.90, 'f1': 0.89},\n        'Entertainment': {'precision': 0.82, 'recall': 0.80, 'f1': 0.81}\n    },\n    'Logistic Regression': {\n        'Business': {'precision': 0.90, 'recall': 0.91, 'f1': 0.90},\n        'Politics': {'precision': 0.87, 'recall': 0.85, 'f1': 0.86},\n        'Sports': {'precision': 0.93, 'recall': 0.92, 'f1': 0.92},\n        'Tech': {'precision': 0.89, 'recall': 0.90, 'f1': 0.89},\n        'Entertainment': {'precision': 0.84, 'recall': 0.83, 'f1': 0.83}\n    }\n}\n\n# Simulate training data category distribution\nsimulated_train_category_distribution = {\n    'Business': 1200,\n    'Politics': 1100,\n    'Sports': 1350,\n    'Tech': 1050,\n    'Entertainment': 900\n}\n\n\nmodel_info = {\n    'Naive Bayes': {\n        'icon': 'calculate',\n        'desc': """"""\n            **Origin & Theory**: Naive Bayes classifiers are a family of simple probabilistic classifiers based on **Bayes' Theorem** with the ""naive"" assumption of conditional independence between features. Specifically, for a given class, the presence or absence of a particular feature (like a word in an article) is assumed to be unrelated to the presence or absence of any other feature.\n            \n            **How it Works**: It calculates the probability of a document belonging to a certain class (category) given the words in it. The formula is:\n            $$ P(Class|Document) \\propto P(Document|Class) \\times P(Class) $$\n            Where $P(Document|Class)$ is simplified by the independence assumption to be the product of probabilities of each word appearing in that class:\n            $$ P(Document|Class) = \\prod_{i=1}^{n} P(Word_i|Class) $$\n            It's particularly effective for text classification due to its simplicity, speed, and good performance even with small datasets. It often uses **Bag of Words** model for document representation.\n\n            **Strengths**:\n            * **Simple and Fast**: Easy to implement and computationally efficient, especially for large datasets.\n            * **Good for Text**: Performs surprisingly well in text classification tasks with relatively small training data.\n            * **Handles High Dimensions**: Effective with high-dimensional feature spaces (like TF-IDF vectors).\n            * **Scalable**: Can handle very large feature sets.\n\n            **Weaknesses**:\n            * **""Naive"" Assumption**: The conditional independence assumption rarely holds true in real-world data, which can limit its accuracy for complex relationships.\n            * **Zero Frequency Problem**: If a word in the test data was not present in the training data, its probability will be zero, leading to zero posterior probability for the entire class (often handled by Laplace smoothing).\n            * **Sensitivity to Data Distribution**: Performance can degrade if data distributions change significantly.\n\n            **Typical Use Cases in NLP**:\n            * Spam detection\n            * Sentiment analysis\n            * Document categorization\n            * Language identification\n        """"""\n    },\n    'SVM': {\n        'icon': 'hub',\n        'desc': """"""\n            **Origin & Theory**: Support Vector Machines (SVMs) are supervised learning models with associated learning algorithms that analyze data for classification and regression analysis. Proposed by Vladimir Vapnik, their core idea is to find an **optimal hyperplane** that best separates the data points of different classes in a high-dimensional space.\n            \n            **How it Works**: The goal is to maximize the **margin** between the hyperplane and the closest data points from each class, known as **support vectors**. A larger margin generally leads to lower generalization error. For non-linearly separable data, SVMs use the **kernel trick**, which implicitly maps the inputs into high-dimensional feature spaces where a linear separation is possible, without explicitly computing the coordinates in that space. Common kernels include Linear, Polynomial, and Radial Basis Function (RBF).\n            $$ \\min_{w, b, \\xi} \\frac{1}{2} ||w||^2 + C \\sum_{i=1}^{n} \\xi_i \\text{ subject to } y_i(w \\cdot x_i - b) \\ge 1 - \\xi_i \\text{ and } \\xi_i \\ge 0 $$\n            Here, $w$ is the normal vector to the hyperplane, $b$ is the offset, $C$ is a regularization parameter, and $\\xi_i$ are slack variables for misclassification.\n\n            **Strengths**:\n            * **Effective in High Dimensional Spaces**: Particularly well-suited for text classification where the number of features (words) can be very large.\n            * **Effective with Clear Margin of Separation**: Works well when there's a clear distinction between classes.\n            * **Memory Efficient**: Uses a subset of training points (support vectors) in the decision function.\n            * **Versatile Kernels**: Can adapt to various data patterns using different kernel functions.\n\n            **Weaknesses**:\n            * **Poor Performance with Large Datasets**: Can be computationally intensive and slow to train on very large datasets.\n            * **Sensitivity to Outliers**: Can be sensitive to noise and outliers as they can heavily influence the hyperplane.\n            * **Choice of Kernel/Parameters**: Performance is highly dependent on the right choice of kernel function and its parameters ($C$, gamma).\n            * **Lack of Probabilities**: By default, SVMs don't output probabilities directly (they can be calibrated, but it adds complexity).\n\n            **Typical Use Cases in NLP**:\n            * Text and hypertext categorization\n            * Spam detection\n            * Handwriting recognition\n            * Gene expression classification\n        """"""\n    },\n    'Random Forest': {\n        'icon': 'forest',\n        'desc': """"""\n            **Origin & Theory**: Random Forest, introduced by Leo Breiman, is an **ensemble learning method** for classification and regression. It operates by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees. It's built on the principle of **bagging (bootstrap aggregating)**.\n            \n            **How it Works**:\n            1.  **Bootstrapping**: Each tree in the forest is trained on a random subset of the training data, sampled with replacement.\n            2.  **Feature Randomness**: When splitting a node during tree construction, only a random subset of features is considered, preventing individual features from dominating the decision-making.\n            3.  **Voting/Averaging**: For classification, the final prediction is determined by majority voting among the trees. For regression, it's the average of their predictions.\n            The combination of these randomizations (data and features) reduces overfitting and improves the model's robustness and accuracy.\n\n            **Strengths**:\n            * **Reduces Overfitting**: By averaging multiple trees, it effectively reduces the risk of overfitting common in individual decision trees.\n            * **High Accuracy**: Often performs very well and provides high accuracy compared to single decision trees.\n            * **Handles Non-linear Relationships**: Can model complex, non-linear relationships.\n            * **Implicit Feature Selection**: Can estimate feature importance, showing which words are most impactful.\n            * **Robust to Outliers/Noise**: Less sensitive to outliers due to the ensemble nature.\n\n            **Weaknesses**:\n            * **Interpretability**: Less interpretable than a single decision tree; understanding the contribution of individual trees is hard.\n            * **Computational Cost**: Can be computationally more expensive and slower to train than simpler models like Naive Bayes, especially with many trees.\n            * **Memory Usage**: Requires more memory as it stores multiple trees.\n\n            **Typical Use Cases in NLP**:\n            * Sentiment analysis\n            * Spam detection\n            * Authorship attribution\n            * Text categorization where complex feature interactions are expected.\n        """"""\n    },\n    'Logistic Regression': {\n        'icon': 'functions',\n        'desc': """"""\n            **Origin & Theory**: Despite its name, Logistic Regression is a statistical model used for **binary classification**. It's a linear model that estimates the probability of an instance belonging to a particular class. It extends to multi-class classification using strategies like One-vs-Rest (OvR) or Multinomial Logistic Regression.\n            \n            **How it Works**: It applies a **sigmoid (logistic) function** to the output of a linear equation, squashing the output into a probability between 0 and 1.\n            $$ P(Y=1|X) = \\frac{1}{1 + e^{-( \\beta_0 + \\beta_1 X_1 + ... + \\beta_n X_n )}} $$\n            The parameters ($\\beta$) are learned by maximizing the likelihood function, typically using gradient descent. For text classification, it handles high-dimensional sparse data well and offers good interpretability through the learned coefficients.\n\n            **Strengths**:\n            * **Simple and Interpretable**: The coefficients can be interpreted as the strength and direction of association between a feature (word) and the log-odds of the dependent variable.\n            * **Efficient**: Fast to train and predict, especially on large datasets.\n            * **Good for High-Dimensional Sparse Data**: Performs well with text data represented by TF-IDF, which is typically sparse.\n            * **Provides Probabilities**: Outputs probabilities directly, which can be useful for ranking or thresholding decisions.\n\n            **Weaknesses**:\n            * **Assumes Linearity**: Assumes a linear relationship between the independent variables and the log-odds of the dependent variable.\n            * **Not Suitable for Complex Relationships**: May not perform as well as more complex models for highly non-linear or intricate data patterns.\n            * **Feature Engineering Dependent**: Performance heavily relies on good feature engineering.\n\n            **Typical Use Cases in NLP**:\n            * Spam filtering\n            * Sentiment analysis (binary classification)\n            * Document classification\n            * Predicting click-through rates\n        """"""\n    }\n}\n\n# Initialize session state for each model's selection status\n# CHANGE 5: No models selected by default\nfor model_name in model_info:\n    if f""{model_name}_selected"" not in st.session_state:\n        st.session_state[f""{model_name}_selected""] = False # Changed to False\n    # Initialize feedback state for each model\n    if f""feedback_{model_name}"" not in st.session_state:\n        st.session_state[f""feedback_{model_name}""] = {""submitted"": False, ""type"": None, ""corrected_category"": None, ""reason"": None}\n\nif 'prediction_made' not in st.session_state:\n    st.session_state.prediction_made = False\nif 'results' not in st.session_state:\n    st.session_state.results = []\nif 'user_input_for_feedback' not in st.session_state: # Store original input for feedback logging\n    st.session_state.user_input_for_feedback = """"\n# Removed st.session_state.article_url and related logic as URL option is removed.\nif 'prediction_text_area' not in st.session_state: # To manage text area content\n    st.session_state.prediction_text_area = """"\n\n\n# --- Initialize app_mode with a default value ---\napp_mode = ""Classifier"" # Default mode\n\n# --- Callback function to toggle selection state (triggered by Streamlit button click) ---\ndef toggle_model_selection_callback(model_name):\n    st.session_state[f""{model_name}_selected""] = not st.session_state[f""{model_name}_selected""]\n\n# --- SIDEBAR NAVIGATION ---\nwith st.sidebar:\n    st.title(""üì∞ NewsTagger AI"")\n    st.markdown(""---"")\n    # Assign to app_mode, which is already defined in the outer scope\n    app_mode = st.radio(""Navigation"", (""Classifier"", ""About the Project""), label_visibility=""hidden"", key=""sidebar_navigation"")\n\n    st.markdown(""---"")\n    st.subheader(""Settings"")\n    # Confidence Threshold Slider\n    confidence_threshold = st.slider(\n        ""Minimum Prediction Confidence"",\n        min_value=0.0,\n        max_value=1.0,\n        value=0.5, # Default threshold\n        step=0.05,\n        help=""Only display predictions with confidence scores above this threshold.""\n    )\n\n# --- MAIN APP UI ---\nif app_mode == ""Classifier"":\n    st.markdown('<h1 style=""text-align: center;"">NewsTagger AI: News Article Classifier</h1>', unsafe_allow_html=True)\n    st.markdown('<p style=""text-align: center; color: #9e9e9e;"">Select models and paste an article to classify it in real-time.</p>', unsafe_allow_html=True) # Updated description\n    st.markdown(""---"")\n\n    # --- CUSTOM MODEL SELECTION WITH VISIBLE ST.BUTTON ---\n    st.subheader(""1. Select Your Models"")\n    cols = st.columns(len(model_info))\n    for i, (name, info) in enumerate(model_info.items()):\n        with cols[i]:\n            is_selected = st.session_state[f""{name}_selected""]\n            selected_class = ""selected"" if is_selected else """"\n            \n            # Use a div to act as the clickable card container\n            # This container will hold both the hidden Streamlit button and the visual card\n            # The onclick event on this container will trigger the hidden button\n            st.markdown(f""""""\n            <div id=""model_card_container_{name.replace(' ', '_')}"" \n                 class=""model-card-container {selected_class}""\n                 onclick=""\n                    var button = document.getElementById('button_to_click_{name.replace(' ', '_')}');\n                    if (button) {{\n                        button.click();\n                    }}\n                 "">\n                <div class=""model-card-visual"">\n                    <span class=""material-icons"">{info['icon']}</span>\n                    <h3>{name}</h3>\n                    <p>Accuracy: {accuracies.get(name, 0):.2%}</p>\n                </div>\n            </div>\n            """""", unsafe_allow_html=True)\n\n            # The actual Streamlit button, which will be styled to be invisible and fill the card.\n            # Its sole purpose is to capture the click and trigger the Streamlit rerun.\n            st.button(\n                label=""Click to Select"", # A simple label\n                key=f""button_to_click_{name.replace(' ', '_')}"", # Unique key\n                on_click=toggle_model_selection_callback,\n                args=(name,),\n                type=""secondary"", # Minimal default styling\n                use_container_width=True,\n                help=f""Toggle selection for {name} model"",\n            )\n            \n            # Inject JS to move the Streamlit button into the custom card container\n            # and apply the model-selection-button class to its parent div.stButton\n            st.markdown(f""""""\n                <script>\n                    var cardContainer = document.getElementById('model_card_container_{name.replace(' ', '_')}');\n                    var stButtonDiv = document.querySelector('[key=""{f""button_to_click_{name.replace(' ', '_')}""}""]').closest('.stButton');\n                    \n                    if (cardContainer && stButtonDiv) {{\n                        // Move the entire stButton div into the custom card container\n                        cardContainer.appendChild(stButtonDiv);\n                        // Add a class to the stButton div for specific CSS targeting\n                        stButtonDiv.classList.add('model-selection-button');\n                    }}\n                </script>\n            """""", unsafe_allow_html=True)\n\n\n    # --- TEXT INPUT ONLY ---\n    st.markdown(""---"")\n    st.subheader(""2. Paste Article Text"") # Simplified header\n\n    # Text area for direct input (removed URL fetch)\n    user_input = st.text_area(""Paste news article content here:"", height=250, \n                              value=st.session_state.prediction_text_area, # Keeps previous input\n                              key=""prediction_text_area_input"",\n                              label_visibility=""hidden"") # Hidden label as placeholder is enough\n\n    # Update session state if user types directly\n    if st.session_state.prediction_text_area_input != st.session_state.prediction_text_area:\n        st.session_state.prediction_text_area = st.session_state.prediction_text_area_input\n\n    # --- ACTION BUTTONS ---\n    st.markdown(""---"")\n    selected_models = [name for name in model_info if st.session_state[f""{name}_selected""]]\n    col1, col2 = st.columns(2)\n    with col1:\n        predict_btn = st.button(""Predict"", use_container_width=True, key=""predict_btn"", \n                               help=""Run classification with selected models"", type=""primary"")\n    with col2:\n        clear_btn = st.button(""Clear Results"", use_container_width=True, key=""clear_btn"", \n                             help=""Clear all predictions and results"")\n\n    if predict_btn:\n        if not user_input.strip():\n            st.warning(""Please enter some text to classify."", icon=""ü•Ä"")\n        elif not selected_models:\n            st.warning(""Please select at least one model."", icon=""ü™´"")\n        else:\n            with st.spinner('Analyzing text with AI models...'):\n                st.session_state.results = []\n                st.session_state.user_input_for_feedback = user_input # Store original input for feedback\n                \n                processed_text = preprocess_text(user_input)\n                text_tfidf = vectorizer.transform([processed_text])\n                \n                # Reset feedback state for all selected models\n                for model_name in selected_models:\n                    st.session_state[f""feedback_{model_name}""] = {""submitted"": False, ""type"": None, ""corrected_category"": None, ""reason"": None}\n\n                for model_name in selected_models:\n                    model = load_model(model_name)\n                    if model:\n                        try:\n                            # CHANGE 3: Measure prediction time\n                            start_time = time.time()\n                            prediction = model.predict(text_tfidf)[0]\n                            probabilities = model.predict_proba(text_tfidf)[0]\n                            end_time = time.time()\n                            prediction_time = end_time - start_time\n\n                            predicted_category = label_encoder.inverse_transform([prediction])[0]\n                            \n                            # Create charts\n                            conf_chart = create_confidence_chart(probabilities, label_encoder.classes_, CATEGORY_COLORS)\n                            \n                            # Feature importance (handled more robustly now)\n                            feat_chart = None\n                            feature_names = vectorizer.get_feature_names_out()\n                            predicted_class_index = label_encoder.transform([predicted_category])[0]\n\n                            importances = None # Initialize to None\n\n                            if hasattr(model, 'feature_importances_'):\n                                # For tree-based models like Random Forest\n                                importances = model.feature_importances_\n                                \n                            elif hasattr(model, 'coef_'):\n                                # For linear models like SVM and Logistic Regression\n                                coef_data = model.coef_\n                                if issparse(coef_data): # Convert sparse to dense if necessary\n                                    coef_data = coef_data.toarray()\n\n                                if coef_data.ndim > 1: # Multi-class scenario\n                                    importances = coef_data[predicted_class_index]\n                                else: # Binary class scenario (should be rare with this dataset)\n                                    importances = coef_data\n                                \n                            elif hasattr(model, 'feature_log_prob_'):\n                                # For Naive Bayes (e.g., MultinomialNB)\n                                log_probs = model.feature_log_prob_\n                                if issparse(log_probs): # Convert sparse to dense if necessary\n                                    log_probs = log_probs.toarray()\n\n                                if log_probs.ndim > 1: # Multi-class\n                                    importances = log_probs[predicted_class_index]\n                                else:\n                                    importances = log_probs # Should not happen for MultinomialNB typically\n                            \n                            # Generate Feature Importance Chart if importances are available\n                            if importances is not None and len(importances) > 0 and len(importances) == len(feature_names):\n                                feat_chart = create_feature_importance_chart(importances, feature_names)\n\n                            # Store results\n                            st.session_state.results.append({\n                                ""name"": model_name,\n                                ""category"": predicted_category,\n                                ""probabilities"": probabilities,\n                                ""confidence"": max(probabilities),\n                                ""conf_chart"": conf_chart,\n                                ""feat_chart"": feat_chart, \n                                ""model"": model,\n                                ""icon"": model_info[model_name]['icon'],\n                                ""desc"": model_info[model_name]['desc'],\n                                ""class_metrics"": simulated_class_metrics.get(model_name, {}),\n                                ""prediction_time"": prediction_time # CHANGE 3: Store prediction time\n                            })\n                        except Exception as e:\n                            st.error(f""Error with {model_name} model: {str(e)}"", icon=""‚ö†Ô∏è"")\n                \n                st.session_state.prediction_made = True\n                st.toast(""Predictions are ready!"", icon=""üèÅ"")\n\n    if clear_btn:\n        st.session_state.prediction_made = False\n        st.session_state.results = []\n        st.session_state.user_input_for_feedback = """"\n        st.session_state.prediction_text_area = """" # Clear text area\n        # Reset all feedback states\n        for model_name in model_info:\n             st.session_state[f""feedback_{model_name}""] = {""submitted"": False, ""type"": None, ""corrected_category"": None, ""reason"": None}\n        st.rerun()\n\n    # --- RESULTS DISPLAY - ORGANIZED TABBED VIEW (CHANGE 4) ---\n    if st.session_state.prediction_made and st.session_state.results:\n        st.markdown(""---"")\n        st.markdown('<h2 style=""text-align: center;"">Prediction Results</h2>', unsafe_allow_html=True)\n        \n        # Filter results based on confidence threshold\n        filtered_results = [\n            res for res in st.session_state.results \n            if res['confidence'] >= confidence_threshold\n        ]\n\n        if not filtered_results:\n            st.info(f""No predictions meet the minimum confidence threshold of {confidence_threshold:.0%}. Try lowering the threshold in the sidebar."", icon=""ü§î"")\n        else:\n            # CHANGE 4: New Tab System - ""Prediction Details"" and ""Compare Models""\n            prediction_details_tab, compare_models_tab = st.tabs([""Prediction Details"", ""Compare Models""])\n            \n            with prediction_details_tab:\n                # Dropdown to select which model's detailed results to view\n                model_names_for_dropdown = [res['name'] for res in filtered_results]\n                \n                if model_names_for_dropdown:\n                    selected_model_name_for_detail = st.selectbox(\n                        ""Select a Model for Detailed View:"",\n                        model_names_for_dropdown,\n                        key=""model_detail_selector""\n                    )\n                    \n                    # Find the selected model's result data\n                    selected_result = next((res for res in filtered_results if res['name'] == selected_model_name_for_detail), None)\n                    \n                    if selected_result:\n                        current_feedback_state = st.session_state[f""feedback_{selected_result['name']}""]\n                        category_color = CATEGORY_COLORS.get(selected_result['category'], '#64B5F6')\n\n                        # Prediction card\n                        st.markdown(f""""""\n                        <div class=""prediction-card"" style=""--category-color: {category_color};"">\n                            <div style=""display: flex; align-items: center; gap: 15px;"">\n                                <span class=""material-icons"" style=""font-size: 3rem;"">{selected_result['icon']}</span>\n                                <div>\n                                    <div class=""prediction-header"">{selected_result['name']} Prediction</div>\n                                    <div class=""prediction-category"">{selected_result['category'].capitalize()}</div>\n                                </div>\n                            </div>\n                        </div>\n                        """""", unsafe_allow_html=True)\n                        \n                        # --- Feedback Section ---\n                        st.markdown(""<br>"", unsafe_allow_html=True) # Add some space\n                        st.markdown(""**Was this prediction helpful?**"")\n                        \n                        if current_feedback_state[""submitted""]:\n                            if current_feedback_state[""type""] == ""Correct"":\n                                st.success(""‚úÖ Thank you for your feedback! Glad it was helpful."")\n                            else: # Incorrect\n                                reason_text = f"" Reason: '{current_feedback_state['reason']}'"" if current_feedback_state['reason'] else """"\n                                st.error(f""‚ùå Thank you for your feedback! Noted that the correct category is **'{current_feedback_state['corrected_category'].capitalize()}'**. {reason_text}"")\n                        else:\n                            col_feedback_yes, col_feedback_no = st.columns(2)\n                            with col_feedback_yes:\n                                if st.button(""üëç Yes, it was correct"", key=f""feedback_yes_{selected_result['name']}"", use_container_width=True):\n                                    log_feedback(\n                                        datetime.now().strftime(""%Y-%m-%d %H:%M:%S""),\n                                        selected_result['name'],\n                                        st.session_state.user_input_for_feedback,\n                                        selected_result['category'],\n                                        ""Correct""\n                                    )\n                                    st.session_state[f""feedback_{selected_result['name']}""][""submitted""] = True\n                                    st.session_state[f""feedback_{selected_result['name']}""][""type""] = ""Correct""\n                                    st.rerun()\n                            with col_feedback_no:\n                                if st.button(""üëé No, it was incorrect"", key=f""feedback_no_{selected_result['name']}"", use_container_width=True):\n                                    st.session_state[f""feedback_{selected_result['name']}""][""type""] = ""Incorrect_Pending""\n                                    st.rerun() # Rerun to show the correct category dropdown\n                            \n                            if current_feedback_state[""type""] == ""Incorrect_Pending"":\n                                correct_category_options = sorted(list(label_encoder.classes_)) # Sort for consistent display\n                                # Pre-select the predicted category in the dropdown, allowing user to change\n                                current_predicted_index = correct_category_options.index(selected_result['category']) if selected_result['category'] in correct_category_options else 0\n\n                                selected_correct_category = st.selectbox(\n                                    ""What was the correct category?"",\n                                    options=correct_category_options,\n                                    index=current_predicted_index,\n                                    key=f""correct_category_select_{selected_result['name']}""\n                                )\n                                feedback_reason = st.text_area(\n                                    ""Optional: Briefly explain why it was incorrect (e.g., 'It's about sports, not entertainment')"",\n                                    key=f""feedback_reason_{selected_result['name']}"",\n                                    height=80\n                                )\n\n                                if st.button(""Submit Correction"", key=f""submit_correction_{selected_result['name']}"", type=""primary""):\n                                    log_feedback(\n                                        datetime.now().strftime(""%Y-%m-%d %H:%M:%S""),\n                                        selected_result['name'],\n                                        st.session_state.user_input_for_feedback,\n                                        selected_result['category'],\n                                        ""Incorrect"",\n                                        selected_correct_category,\n                                        feedback_reason\n                                    )\n                                    st.session_state[f""feedback_{selected_result['name']}""][""submitted""] = True\n                                    st.session_state[f""feedback_{selected_result['name']}""][""type""] = ""Incorrect""\n                                    st.session_state[f""feedback_{selected_result['name']}""][""corrected_category""] = selected_correct_category\n                                    st.session_state[f""feedback_{selected_result['name']}""][""reason""] = feedback_reason\n                                    st.rerun()\n                        \n                        st.markdown(""---"") # Separator after feedback section\n\n                        # Metrics section\n                        st.subheader(""Model Performance & Confidence"")\n                        col_metrics_1, col_metrics_2, col_metrics_3 = st.columns(3) # Added a column for prediction time\n                        with col_metrics_1:\n                            st.markdown(""""""\n                            <div class=""metric-card"">\n                                <div class=""metric-label"">Model Accuracy (on Test Set)</div>\n                                <div class=""metric-value"">{:.2%}</div>\n                            </div>\n                            """""".format(accuracies.get(selected_result['name'], 0)), unsafe_allow_html=True)\n                        with col_metrics_2:\n                            # CHANGE 2: Enlarge Confidence Gauge\n                            fig_gauge = go.Figure(go.Indicator(\n                                mode=""gauge+number"",\n                                value=selected_result['confidence'],\n                                domain={'x': [0, 1], 'y': [0, 1]},\n                                title={'text': ""Prediction Confidence""},\n                                gauge={\n                                    'axis': {'range': [None, 1], 'tickwidth': 1, 'tickcolor': ""#424242""},\n                                    'bar': {'color': CATEGORY_COLORS.get(selected_result['category'], '#64B5F6')}, # Color based on predicted category\n                                    'bgcolor': ""#212121"",\n                                    'borderwidth': 2,\n                                    'bordercolor': ""#424242"",\n                                    'steps': [\n                                        {'range': [0, 0.25], 'color': ""rgba(255, 0, 0, 0.2)""},    # Low\n                                        {'range': [0.25, 0.5], 'color': ""rgba(255, 165, 0, 0.2)""}, # Medium\n                                        {'range': [0.5, 0.75], 'color': ""rgba(173, 255, 47, 0.2)""}, # Good\n                                        {'range': [0.75, 1], 'color': ""rgba(0, 128, 0, 0.2)""}    # High\n                                    ],\n                                    'threshold': {\n                                        'line': {'color': ""white"", 'width': 2},\n                                        'thickness': 0.75,\n                                        'value': selected_result['confidence']\n                                    }\n                                }\n                            ))\n                            # Increased height from 200 to 300\n                            fig_gauge.update_layout(\n                                height=300, \n                                margin=dict(l=10, r=10, b=10, t=50), \n                                paper_bgcolor=""rgba(0,0,0,0)"", \n                                font_color=""#e0e0e0""\n                            )\n                            st.plotly_chart(fig_gauge, use_container_width=True)\n                        \n                        with col_metrics_3: # CHANGE 3: Display prediction time\n                             st.markdown(f""""""\n                            <div class=""metric-card"">\n                                <div class=""metric-label"">Prediction Time</div>\n                                <div class=""metric-value"">{selected_result['prediction_time']:.3f} s</div>\n                            </div>\n                            """""", unsafe_allow_html=True)\n\n\n                        # Charts section\n                        st.subheader(""Detailed Confidence Scores"")\n                        st.plotly_chart(selected_result['conf_chart'], use_container_width=True)\n                        \n                        # Feature importance chart\n                        if selected_result['feat_chart']: # Only display if a chart was successfully generated\n                            st.subheader(""Top Influential Words (Overall)"")\n                            st.plotly_chart(selected_result['feat_chart'], use_container_width=True)\n                        else:\n                            st.info(f""Overall feature importance visualization is not available or could not be generated for {selected_result['name']} model. This may be due to the model type or an internal error."", icon=""‚ÑπÔ∏è"")\n                        \n                        # Detailed Class-wise Performance Metrics\n                        if selected_result['class_metrics']:\n                            st.subheader(""Detailed Category Performance (on Test Set)"")\n                            metrics_df = pd.DataFrame(selected_result['class_metrics']).T # Transpose for better display\n                            metrics_df = metrics_df.applymap(lambda x: f""{x:.2f}"") # Format to 2 decimal places\n                            st.dataframe(metrics_df, use_container_width=True)\n                            st.info(""These metrics (Precision, Recall, F1-Score) show how well the model performed for each category on a separate test dataset. Higher values indicate better performance for that specific category."", icon=""üìä"")\n\n                        # About This Model - using expander\n                        with st.expander(f""About the {selected_result['name']} Model"", expanded=False):\n                            st.info(selected_result['desc'], icon=""üí°"") # This now uses the enriched description\n                else:\n                    st.info(""Select a model from the dropdown above to view its detailed prediction results."", icon=""üëÜ"")\n            \n            with compare_models_tab:\n                st.subheader(""Model Prediction Comparison"")\n                if filtered_results:\n                    comparison_data = []\n                    for res in filtered_results:\n                        comparison_data.append({\n                            ""Model"": res['name'],\n                            ""Predicted Category"": res['category'],\n                            ""Confidence"": f""{res['confidence']:.2%}"",\n                            ""Prediction Time"": f""{res['prediction_time']:.3f} s"" # CHANGE 3: Add time to comparison\n                        })\n                    \n                    comparison_df = pd.DataFrame(comparison_data)\n                    st.dataframe(comparison_df, use_container_width=True)\n\n                    st.markdown(""---"")\n                    st.subheader(""Confidence Comparison Chart"")\n                    \n                    # Bar chart for confidence comparison\n                    comp_fig = go.Figure(go.Bar(\n                        x=[res['name'] for res in filtered_results],\n                        y=[res['confidence'] for res in filtered_results],\n                        marker_color=[CATEGORY_COLORS.get(res['category'], '#64B5F6') for res in filtered_results],\n                        text=[f""{res['confidence']:.1%}"" for res in filtered_results],\n                        textposition='outside'\n                    ))\n                    comp_fig.update_layout(\n                        title_text=""Predicted Category Confidence by Model"",\n                        title_x=0.5,\n                        xaxis_title=""Model"",\n                        yaxis_title=""Confidence"",\n                        plot_bgcolor='rgba(0,0,0,0)',\n                        paper_bgcolor='rgba(0,0,0,0)',\n                        font_color='#e0e0e0',\n                        yaxis=dict(range=[0,1], gridcolor='#424242'),\n                        xaxis=dict(showgrid=False)\n                    )\n                    st.plotly_chart(comp_fig, use_container_width=True)\n                else:\n                    st.info(""No predictions met the minimum confidence threshold for comparison. Run predictions first and ensure at least one model's confidence is above the set threshold."", icon=""ü§î"")\n\n\nelif app_mode == ""About the Project"":\n    st.markdown('<h1 style=""text-align: center;"">About This Project</h1>', unsafe_allow_html=True)\n    st.info(""This is an AI-powered tool to classify news articles, showcasing a full machine learning workflow."", icon=""‚ÑπÔ∏è"")\n    \n    st.markdown(""""""\n    ## Overview\n    This application uses machine learning models to classify news articles into categories such as Business, Politics, Sports, etc. \n    It demonstrates an end-to-end NLP classification pipeline including text preprocessing, feature extraction, and model prediction.\n    \n    ## How It Works\n    1. **Text Preprocessing**: The input text is cleaned by converting to lowercase, removing special characters, and normalizing whitespace.\n    2. **Feature Extraction**: Text is converted to numerical features using TF-IDF vectorization.\n    3. **Model Prediction**: Multiple machine learning models make predictions on the processed text.\n    4. **Result Visualization**: Detailed insights and visualizations are provided for each model's prediction.\n    """""")\n    \n    # --- Interactive Model Glossary ---\n    st.markdown(""## Models Used"")\n    for model_name, info in model_info.items():\n        with st.expander(f""**{model_name}** (Accuracy: {accuracies.get(model_name, 0):.2%})"", expanded=False):\n            st.markdown(info['desc'], unsafe_allow_html=True) \n            \n            # Display class-wise metrics in the About section as well\n            if model_name in simulated_class_metrics:\n                st.markdown(""#### Performance Per Category (on Test Set)"")\n                metrics_df = pd.DataFrame(simulated_class_metrics[model_name]).T\n                metrics_df = metrics_df.applymap(lambda x: f""{x:.2f}"") # Format to 2 decimal places\n                st.dataframe(metrics_df, use_container_width=True)\n        st.markdown(""---"") # Separator between expanders\n\n    # --- Meet the Categories Section ---\n    st.markdown(""## Meet the Categories"")\n    st.info(""Here are the news categories this model can identify, along with a brief description of each:"", icon=""üìñ"")\n    \n    for category, description in CATEGORY_DESCRIPTIONS.items():\n        st.markdown(f""### {category.capitalize()}"")\n        st.markdown(description)\n        st.markdown("""") # Add a small space\n\n    # NEW: Training Data Category Distribution\n    st.markdown(""## Training Data Insights"")\n    st.info(""Understanding the distribution of categories in the training data can help explain model performance and potential biases. Models often perform better on categories with more training examples."", icon=""üìö"")\n    \n    if simulated_train_category_distribution:\n        category_dist_df = pd.DataFrame(list(simulated_train_category_distribution.items()), \n                                        columns=['Category', 'Article Count'])\n        fig = go.Figure(go.Bar(\n            x=category_dist_df['Category'], y=category_dist_df['Article Count'],\n            marker_color=[CATEGORY_COLORS.get(cat, '#FFC107') for cat in category_dist_df['Category']] # Use category colors\n        ))\n        fig.update_layout(\n            title_text='Training Data Category Distribution', title_x=0.5,\n            xaxis_title=""Category"", yaxis_title=""Number of Articles"",\n            plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)',\n            font_color='#e0e0e0', xaxis=dict(showgrid=False), yaxis=dict(gridcolor='#424242')\n        )\n        st.plotly_chart(fig, use_container_width=True)\n    else:\n        st.warning(""Training data category distribution not available."", icon=""‚ö†Ô∏è"")\n\n    # --- Basic Feedback Analytics ---\n    st.markdown(""## User Feedback Analytics"")\n    feedback_file = 'user_feedback.csv'\n    if os.path.exists(feedback_file):\n        try:\n            feedback_df = pd.read_csv(feedback_file)\n            \n            if feedback_df.empty:\n                st.info(""The feedback file is empty. No feedback has been logged yet."", icon=""ü§∑"")\n            else:\n                # Check if 'feedback_type' column exists before using it\n                if 'feedback_type' not in feedback_df.columns:\n                    st.error(""Error: Required column 'feedback_type' not found in user_feedback.csv. The file might be corrupted or incorrectly formatted."", icon=""‚ö†Ô∏è"")\n                    # IMPORTANT: Removed 'return' here.\n                    # The code will now simply not enter the 'else' block below\n                    # and thus won't try to use 'feedback_type'.\n                else: # Only proceed with charts if 'feedback_type' column is present\n                    st.info(f""Total feedback entries: **{len(feedback_df)}**"", icon=""üìà"")\n\n                    # Correct vs. Incorrect Pie Chart\n                    feedback_counts = feedback_df['feedback_type'].value_counts()\n                    fig_pie = go.Figure(go.Pie(\n                        labels=feedback_counts.index,\n                        values=feedback_counts.values,\n                        hole=.3,\n                        marker_colors=['#4CAF50', '#FF4500'], # Green for Correct, Orange-red for Incorrect\n                        textinfo='percent+label'\n                    ))\n                    fig_pie.update_layout(\n                        title_text='Feedback Distribution', title_x=0.5,\n                        paper_bgcolor='rgba(0,0,0,0)',\n                        font_color='#e0e0e0',\n                        height=300,\n                        margin=dict(l=20, r=20, t=50, b=20)\n                    )\n                    st.plotly_chart(fig_pie, use_container_width=True)\n\n                    # Top Corrected Categories\n                    # Check for 'correct_category' column before using it\n                    if 'correct_category' in feedback_df.columns:\n                        incorrect_feedback = feedback_df[feedback_df['feedback_type'] == 'Incorrect']\n                        if not incorrect_feedback.empty:\n                            corrected_category_counts = incorrect_feedback['correct_category'].value_counts().head(5)\n                            st.markdown(""#### Top 5 Most Corrected Categories"")\n                            corrected_cat_fig = go.Figure(go.Bar(\n                                x=corrected_category_counts.index,\n                                y=corrected_category_counts.values,\n                                marker_color=[CATEGORY_COLORS.get(cat, '#FF4500') for cat in corrected_category_counts.index]\n                            ))\n                            corrected_cat_fig.update_layout(\n                                title_text='Categories Most Frequently Corrected To', title_x=0.5,\n                                xaxis_title=""Category"",\n                                yaxis_title=""Count"",\n                                plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)',\n                                font_color='#e0e0e0',\n                                yaxis=dict(gridcolor='#424242'), xaxis=dict(showgrid=False)\n                            )\n                            st.plotly_chart(corrected_cat_fig, use_container_width=True)\n                        else:\n                            st.info(""No 'Incorrect' feedback yet to analyze corrected categories."", icon=""ü§∑"")\n                    else:\n                        st.warning(""Column 'correct_category' not found. Cannot display 'Top 5 Most Corrected Categories'. This might happen if no 'Incorrect' feedback has been submitted yet."", icon=""‚ö†Ô∏è"")\n            \n        except pd.errors.EmptyDataError:\n            st.info(""The feedback file is empty. No feedback has been logged yet."", icon=""ü§∑"")\n        except Exception as e:\n            st.error(f""An unexpected error occurred while loading feedback data: {e}"", icon=""‚ö†Ô∏è"")\n    else:\n        st.info(""No feedback data found. The `user_feedback.csv` file does not exist yet."", icon=""ü§∑"")\n\n    st.markdown(""""""\n    ## Technical Stack\n    - Python\n    - Scikit-learn (Machine Learning)\n    - Streamlit (Web Interface)\n    - Plotly (Visualizations)\n    \n    ## Development Notes\n    This project showcases:\n    - Multi-model comparison and evaluation.\n    - Interactive visualization of model predictions.\n    - User feedback collection for continuous improvement.\n    - Clean UI/UX design with a dark theme.\n    """""")","tech","Correct","",""
